# region: outer menu operations
menu_name = "Exploitation tools"
menu_items = [
    "ATScan",
    "SQLMap",
    "Shellnoob",
    "Commix",
    "FTP Autobypasser",
    "JBoss-Autopwn",
    "Blind SQL injections",
    "Android passcode bruteforce",
    "Joomla SQL injection"
]

menu_items.append("Back")
# endregion

# region: additonal imports
import os
import sys

import shutil
import subprocess

from colorama import Fore
# endregion

# region: class helpers
def safe_print(ctx, text):
    try:
        p = ctx.get("print")
        if p:
            p(text)
        else:
            print(text)
    except Exception:
        print(text)

def safe_input(prompt, ctx):
    input_color = None
    try:
        input_color = ctx.get("input_color")
    except Exception:
        input_color = None

    if not input_color:
        input_color = Fore.LIGHTBLACK_EX
    colored_prompt = f"{input_color}{prompt}"

    try:
        return input(colored_prompt)
    except Exception:
        return input(prompt)
# endregion

# region: override class: atscan
class ATScan:
    menu_items = [
        "Run interactive",
        "Back"
    ]
        
    def __init__(self, ctx=None):
        self.ctx = ctx or {}

    def run(self, ctx):
        self.ctx = ctx
        safe_print(ctx, f"[*] ATScan: selected '{ctx.get('item')}'")
        self.sub_menu(ctx)

    def sub_menu(self, ctx):
        safe_print(ctx, "\nATScan options:")
        for i, it in enumerate(self.menu_items, 1):
            safe_print(ctx, f"  [{i}] {it}")
        safe_print(ctx, "")
            
        choice = safe_input(ctx.get("prompt", "root ~# "), ctx).strip()
        
        if not choice.isdigit() or not (1 <= int(choice) <= len(self.menu_items)):
            self.__init__()

        idx = int(choice) - 1
        sel = self.menu_items[idx]

        if sel.lower() == "back":
            return

        if "interactive" in sel:
            self.run_interactive(ctx)

    def run_interactive(self, ctx):
        safe_print(ctx, "\n[*] Starting atscan session.\n")

        os.system("rm -rf ATSCAN")
        os.system("git clone --depth=1 https://github.com/AlisamTechnology/ATSCAN.git && cd ATSCAN && perl atscan.pl")

        safe_print(ctx, "\n[*] ATScan session finished.\n")
# endregion

# region: override class: sqlmap
class SQLMap:
    menu_items = [
        "Run interactive",
        "Back"
    ]
        
    def __init__(self, ctx=None):
        self.ctx = ctx or {}

        self.tool_direction = os.path.join(os.getcwd(), "tools")
        self.install_direction = os.path.join(self.tool_direction, "SQLMap")

        self.git_repository = "https://github.com/sqlmapproject/sqlmap.git"

        if not os.path.isdir(self.tool_direction):
            os.makedirs(self.tool_direction, exist_ok=True)

        if not self.installed():
            self.install()
        
    def installed(self):
        return os.path.isdir(self.install_direction) and os.path.exists(os.path.join(self.install_direction, "sqlmap.py"))

    def install(self):
        safe_print(self.ctx, "[*] Installing SQLMap...")

        os.makedirs(os.path.dirname(self.install_direction), exist_ok=True)
        os.system(f"git clone --depth=1 {self.git_repository} {self.install_direction}")

        safe_print(self.ctx, "[+] SQLMap installed successfully.")

    def run(self, ctx):
        self.ctx = ctx
        safe_print(ctx, f"[*] SQLMap: selected '{ctx.get('item')}'")
        self.sub_menu(ctx)

    def sub_menu(self, ctx):
        safe_print(ctx, "\nSQLMap options:")
        for i, it in enumerate(self.menu_items, 1):
            safe_print(ctx, f"  [{i}] {it}")
        safe_print(ctx, "")
            
        choice = safe_input(ctx.get("prompt", "root ~# "), ctx).strip()
        
        if not choice.isdigit() or not (1 <= int(choice) <= len(self.menu_items)):
            self.__init__()

        idx = int(choice) - 1
        sel = self.menu_items[idx]

        if sel.lower() == "back":
            return

        if "interactive" in sel:
            self.run_interactive(ctx)

    def run_interactive(self, ctx):
        safe_print(ctx, "\n[*] Starting SQLMap interactive session.\n")

        if not self.installed():
            safe_print(ctx, "[*] SQLMap not installed. Installing now...")
            self.install()

        target = safe_input("Enter target URL for SQLMap: ", ctx).strip()
        if not target:
            safe_print(ctx, "[!] No target provided — aborting.")
            return

        cmd = f"python {os.path.join(self.install_direction, 'sqlmap.py')} -u \"{target}\" --batch"

        safe_print(ctx, f"[*] Running command:\n {cmd}\n")
        safe_print(ctx, "[!] Press Ctrl+C to stop SQLMap\n")

        try:
            os.system(cmd)
        except KeyboardInterrupt:
            safe_print(ctx, "\n[*] SQLMap session stopped by user.")

        safe_print(ctx, "\n[*] SQLMap session finished.\n")
# endregion

# region: override class: shellnoob
class Shellnoob:
    menu_items = [
        "Run interactive",
        "Back"
    ]
        
    def __init__(self, ctx=None):
        self.ctx = ctx or {}

        self.tool_direction = os.path.join(os.getcwd(), "tools")
        self.install_direction = os.path.join(self.tool_direction, "shellnoob")

        self.git_repository = "https://github.com/reyammer/shellnoob.git"
        self.entry_script = os.path.join(self.install_direction, "shellnoob.py")

        if not os.path.isdir(self.tool_direction):
            os.makedirs(self.tool_direction, exist_ok=True)

        if not self.installed():
            self.install()
        
    def installed(self):
        return os.path.isdir(self.install_direction) and os.path.exists(os.path.join(self.install_direction, "shellnoob.py"))

    def install(self):
        safe_print(self.ctx, "[*] Installing ShellNoob...")

        if os.path.isdir(self.install_direction) and os.path.isdir(os.path.join(self.install_direction, ".git")):
            safe_print(self.ctx, "[*] Repo already exists — attempting 'git pull' to update.")
            try:
                res = subprocess.run(["git", "-C", self.install_direction, "pull"],
                                      check=False, capture_output=True, text=True)

                if res.returncode != 0:
                    safe_print(self.ctx, f"[!] git pull failed: {res.stderr.strip() or res.stdout.strip()}")
                else:
                    safe_print(self.ctx, "[*] git pull completed.")
            except FileNotFoundError:
                safe_print(self.ctx, "[!] git not found. Please install git or clone manually.")
                return
        else:
            try:
                res = subprocess.run(["git", "clone", "--depth=1", self.git_repository, self.install_direction],
                                      check=False, capture_output=True, text=True)
                if res.returncode != 0:
                    safe_print(self.ctx, f"[!] git clone failed: {res.stderr.strip() or res.stdout.strip()}")
                    return
                safe_print(self.ctx, "[*] git clone completed.")
            except FileNotFoundError:
                safe_print(self.ctx, "[!] git not found. Please install git or clone manually.")
                return

        possible_script = os.path.join(self.install_direction, "shellnoob.py")

        if os.path.exists(possible_script):
            self.entry_script = possible_script
            safe_print(self.ctx, "[*] shellnoob.py found.")
        else:
            found = None
            for root, dirs, files in os.walk(self.install_direction):
                if "shellnoob.py" in files:
                    found = os.path.join(root, "shellnoob.py")
                    break

            if found:
                self.entry_script = found
                safe_print(self.ctx, f"[*] shellnoob.py located at {found}.")
            else:
                safe_print(self.ctx, "[!] shellnoob.py not found in repo. Installation incomplete.")
                return

        safe_print(self.ctx, "[*] ShellNoob installation finished (script located).")

    def run(self, ctx):
        self.ctx = ctx
        safe_print(ctx, f"[*] Shellnoob: selected '{ctx.get('item')}'")
        self.sub_menu(ctx)

    def sub_menu(self, ctx):
        safe_print(ctx, "\nShellnoob options:")
        for i, it in enumerate(self.menu_items, 1):
            safe_print(ctx, f"  [{i}] {it}")
        safe_print(ctx, "")
            
        choice = safe_input(ctx.get("prompt", "root ~# "), ctx).strip()
        
        if not choice.isdigit() or not (1 <= int(choice) <= len(self.menu_items)):
            self.__init__()

        idx = int(choice) - 1
        sel = self.menu_items[idx]

        if sel.lower() == "back":
            return

        if "interactive" in sel:
            self.run_interactive(ctx)

    def run_interactive(self, ctx):
        safe_print(ctx, "\n[*] Starting ShellNoob interactive session.\n")

        if not self.installed():
            safe_print(ctx, "[*] SQLMap not installed. Installing now...")
            self.install()

        safe_print(ctx, "You can run ShellNoob in installer mode or pass custom arguments to it.")
        safe_print(ctx, "Examples: --install or --generate --arch x86 --format c")

        user_args = safe_input("shellnoob args (leave empty to show help): ", ctx).strip()
        if os.path.exists(self.entry_script):
            python_exe = shutil.which("python3") or shutil.which("python") or "python"
            cmd_parts = [python_exe, f"\"{self.entry_script}\""]
        elif shutil.which("shellnoob"):
            cmd_parts = [shutil.which("shellnoob")]
        else:
            cmd_parts = [f"python \"{os.path.join(self.install_direction, 'shellnoob.py')}\""]

        if user_args:
            cmd_parts.append(user_args)

        final_cmd = " ".join(cmd_parts)

        safe_print(ctx, "\n[+] Built command:")
        safe_print(ctx, f"    {final_cmd}\n")

        confirm = safe_input("Run this command? (Y/n): ", ctx).strip().lower()
        if confirm and confirm in ("n", "no"):
            safe_print(ctx, "[*] Aborted by user.")
            return

        safe_print(ctx, "[*] Running ShellNoob...")

        try:
            subprocess.run(final_cmd, shell=True)
        except KeyboardInterrupt:
            safe_print(ctx, "\n[*] ShellNoob stopped by user.")
        except Exception as e:
            safe_print(ctx, f"[!] Error while running ShellNoob: {e}")
        finally:
            safe_print(ctx, "\n[*] ShellNoob session finished.\n")
# endregion

# region: override class: commix
class Commix:
    menu_items = [
        "Run interactive",
        "Back"
    ]
        
    def __init__(self, ctx=None):
        self.ctx = ctx or {}

        self.tool_direction = os.path.join(os.getcwd(), "tools")
        self.install_direction = os.path.join(self.tool_direction, "Commix")

        self.git_repository = "https://github.com/stasinopoulos/commix.git"

        if not os.path.isdir(self.tool_direction):
            os.makedirs(self.tool_direction, exist_ok=True)

        if not self.installed():
            self.install()
        
    def installed(self):
        return os.path.isdir(self.install_direction) and os.path.exists(os.path.join(self.install_direction, "commix.py"))

    def install(self):
        safe_print(self.ctx, "[*] Installing Commix...")

        os.makedirs(os.path.dirname(self.install_direction), exist_ok=True)
        os.system(f"git clone --depth=1 {self.git_repository} {self.install_direction}")

        safe_print(self.ctx, "[+] Commix installed successfully.")

    def run(self, ctx):
        self.ctx = ctx
        safe_print(ctx, f"[*] Commix: selected '{ctx.get('item')}'")
        self.sub_menu(ctx)

    def sub_menu(self, ctx):
        safe_print(ctx, "\nCommix options:")
        for i, it in enumerate(self.menu_items, 1):
            safe_print(ctx, f"  [{i}] {it}")
        safe_print(ctx, "")
            
        choice = safe_input(ctx.get("prompt", "root ~# "), ctx).strip()
        
        if not choice.isdigit() or not (1 <= int(choice) <= len(self.menu_items)):
            self.__init__()

        idx = int(choice) - 1
        sel = self.menu_items[idx]

        if sel.lower() == "back":
            return

        if "interactive" in sel:
            self.run_interactive(ctx)

    def run_interactive(self, ctx):
        safe_print(ctx, "\n[*] Starting commix session.\n")

        if not self.installed():
            safe_print(ctx, "[*] Commix not installed. Installing now...")
            self.install()

        safe_print(ctx, "[*] Launching Commix...")
        commix_py = os.path.join(self.install_direction, "commix.py")
        
        if not os.path.exists(commix_py):
            safe_print(ctx, "[!] commix.py not found. Aborting launch.")
            return

        try:
            proc = subprocess.Popen([sys.executable, "commix.py"],
                                    cwd=self.install_direction)

            safe_print(ctx, f"[*] Commix started (PID {proc.pid}). Attach to it in your terminal if needed.")
            proc.wait()
            safe_print(ctx, "[*] Commix process finished.")
        except Exception as e:
            safe_print(ctx, f"[!] Failed to launch Commix: {e}")
            return

        safe_print(ctx, "\n[*] Commix session finished.\n")
# endregion

# region: actions utility
def run_action(action, ctx):
    if isinstance(action, type):
        inst = action(ctx)
        
        if hasattr(inst, "run"):
            return inst.run(ctx)
        
        elif callable(inst):
            return inst(ctx)
        
    if hasattr(action, "run") and callable(getattr(action, "run")):
        return action.run(ctx)
    
    if callable(action):
        return action(ctx)

    raise TypeError("Action is not runnable")
# endregion

# region: executable function
def execute(ctx):
    item = ctx.get("item")

    fprint = ctx.get("print", lambda t: safe_print(ctx, t))
    wprint = ctx.get("warn", lambda t: safe_print(ctx, t))

    fprint(f"[*] Executing: {item}")
    actions = {
        "ATScan": ATScan,
        "SQLMap": SQLMap,
        "Shellnoob": Shellnoob,
        "Commix": Commix,
        #"FTP Autobypasser",
        #"JBoss-Autopwn",
        #"Blind SQL injections",
        #"Android passcode bruteforce",
        #"Joomla SQL injection"
    }

    action = actions.get(item)

    if not action:
        wprint(f"[!] Unknown action: {item}")
        return

    try:
        run_action(action, ctx)
    except Exception as e:
        wprint(f"[!] Error running action '{item}': {e}")
# endregion